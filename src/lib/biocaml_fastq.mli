(** FASTQ data. *)


type item = {
  name: string;
  sequence: string;
  comment: string;
  qualities: string;
}
with sexp
(** Type of FASTQ items. *)


(** Errors. All errors generated by any function in the [Fastq] module
    are defined here.

    - [`sequence_and_qualities_do_not_match (position, sequence,
    qualities)] - given [sequence] and [qualities] at given [position]
    are of different lengths.

    - [`wrong_name_line x] - name line [x] does not start with '@'

    - [`wrong_comment_line _] - comment line does not start with '+'

    - [`incomplete_input (position, lines, s)] - the input ended
    prematurely. Trailing contents, which cannot be used to fully
    construct an item, are provided: [lines] is any complete lines
    parsed and [s] is any final string not ending in a newline.
*)
module Error : sig

  type t =
      [ `sequence_and_qualities_do_not_match of Biocaml_pos.t * string * string
      | `wrong_comment_line of Biocaml_pos.t * string
      | `wrong_name_line of Biocaml_pos.t * string
      | `incomplete_input of Biocaml_pos.t * string list * string option
      ]
  with sexp

  val t_to_string : t -> string
    (** Transform error to a human-readable string. *)

end

val in_channel_to_item_stream : ?filename:string -> in_channel ->
  (item, Error.t) Core.Result.t Stream.t

module Transform: sig
  val string_to_item:
    ?filename:string -> unit ->
    (string, (item, Error.t) Core.Result.t) Biocaml_transform.t
(** Create a full {i stoppable} [Biocaml_transform.t] from arbitrary strings to
    [item] values.*)

  val item_to_string: unit -> (item, string) Biocaml_transform.t
(** Create a full {i stoppable} [Biocaml_transform.t] from [item]
    values to strings. *)

  val trim:
    [ `beginning of int | `ending of int ] ->
    (item, (item, [`invalid_size of int]) Core.Result.t) Biocaml_transform.t
(** Create a full {i stoppable} [Biocaml_transform.t] that trims FASTQ
    items. *)
end




