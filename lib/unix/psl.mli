(** PSL files. Tested only on PSL files generated by BLAT version 34,
    which output psLayout version 3 files. *)
type item = {
  matches : int; (** number of bases that match that aren't repeats *)
  mismatches : int; (** number of bases that don't match *)
  rep_matches : int; (** number of bases that match but are part of repeats *)
  n_count : int; (** number of 'N' bases *)
  q_num_insert : int; (** number of inserts in query *)
  q_base_insert : int; (** number of bases inserted in query *)
  t_num_insert : int; (** number of inserts in target *)
  t_base_insert : int; (** number of bases inserted in target *)
  q_name : string; (** query sequence name *)
  q_strand : char; (** '+' or '-' for query strand *)
  q_size : int; (** query sequence size *)
  q_start : int; (** alignment start position in query *)
  q_end : int; (** alignment end position in query *)
  t_name : string; (** target sequence name *)
  t_strand : char option; (** target strand for translated alignments *)
  t_size : int; (** target sequence size *)
  t_start : int; (** alignment start position in target *)
  t_end : int; (** alignment end position in target *)
  block_count : int; (** number of blocks in the alignment (a block contains no gaps) *)
  block_sizes : int list; (** sizes of each block *)
  q_starts : int list; (** starting positions of each block in query *)
  t_starts : int list; (** starting positions of each block in target *)
}

module Error : sig
  type t = [
  | `incomplete_input of Pos.t * string list * string option
  | `invalid_int of Pos.t * string * string
  | `invalid_strands of Pos.t * string * string
  | `invalid_number_of_columns of Pos.t * string * int
  ]
end

exception Error of Error.t

val in_channel_to_item_stream : ?buffer_size:int -> ?filename:string -> in_channel ->
  (item, [> Error.t]) result Stream.t

val in_channel_to_item_stream_exn:
  ?buffer_size:int -> ?filename:string -> in_channel -> item Stream.t

module Transform : sig

  val string_to_item :
    ?filename:string ->
    unit ->
    (string, (item, [> Error.t]) result) Tfxm.t

end

val line_to_item : Pos.t -> Line.t -> (item, Error.t) result


(** {2 S-Expressions } *)

val item_of_sexp : Sexplib.Sexp.t -> item
val sexp_of_item : item -> Sexplib.Sexp.t
