(** PSL files. Tested only on PSL files generated by BLAT version 34,
    which output psLayout version 3 files. *)
type item =
  { matches : int (** number of bases that match that aren't repeats *)
  ; mismatches : int (** number of bases that don't match *)
  ; rep_matches : int (** number of bases that match but are part of repeats *)
  ; n_count : int (** number of 'N' bases *)
  ; q_num_insert : int (** number of inserts in query *)
  ; q_base_insert : int (** number of bases inserted in query *)
  ; t_num_insert : int (** number of inserts in target *)
  ; t_base_insert : int (** number of bases inserted in target *)
  ; q_name : string (** query sequence name *)
  ; q_strand : char (** '+' or '-' for query strand *)
  ; q_size : int (** query sequence size *)
  ; q_start : int (** alignment start position in query *)
  ; q_end : int (** alignment end position in query *)
  ; t_name : string (** target sequence name *)
  ; t_strand : char option (** target strand for translated alignments *)
  ; t_size : int (** target sequence size *)
  ; t_start : int (** alignment start position in target *)
  ; t_end : int (** alignment end position in target *)
  ; block_count : int (** number of blocks in the alignment (a block contains no gaps) *)
  ; block_sizes : int list (** sizes of each block *)
  ; q_starts : int list (** starting positions of each block in query *)
  ; t_starts : int list (** starting positions of each block in target *)
  }

module Error : sig
  type t =
    [ `incomplete_input of Biocaml.Pos.t * string list * string option
    | `invalid_int of Biocaml.Pos.t * string * string
    | `invalid_strands of Biocaml.Pos.t * string * string
    | `invalid_number_of_columns of Biocaml.Pos.t * string * int
    ]
end

exception Error of Error.t

val in_channel_to_item_stream
  :  ?buffer_size:int
  -> ?filename:string
  -> In_channel.t
  -> (item, [> Error.t ]) result Stream.t

val in_channel_to_item_stream_exn
  :  ?buffer_size:int
  -> ?filename:string
  -> In_channel.t
  -> item Stream.t

module Transform : sig
  val string_to_item
    :  ?filename:string
    -> unit
    -> (string, (item, [> Error.t ]) result) Tfxm.t
end

val line_to_item : Biocaml.Pos.t -> Biocaml.Line.t -> (item, Error.t) result

(** {2 S-Expressions } *)

val item_of_sexp : Sexplib.Sexp.t -> item
val sexp_of_item : item -> Sexplib.Sexp.t
